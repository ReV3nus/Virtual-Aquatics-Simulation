#pragma kernel CalcPhillipsSpectrum
#pragma kernel CalcFFTCoefficientW
#pragma kernel CalcPhillipsSpectrumWithTime
#pragma kernel CalcFFTonAxisX
#pragma kernel CalcFFTonAxisZ
#pragma kernel updateHeight
#pragma kernel CalcHeightByDFT

#define THREAD_X 8
#define THREAD_Y 8
#define _Pi 3.1415926535897932384626433832795
#define _G 9.79

struct Complex
{
    float r;
    float i;
};
Complex ComplexMult(Complex a, Complex b)
{
    Complex ret;
    ret.r = a.r * b.r - a.i * b.i;
    ret.i = a.r * b.i + a.i * b.r;
    return ret;
}
float2 ComplexMultFloat(float2 a, float2 b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}
Complex Float2Complex(float r, float i)
{
    Complex ret;
    ret.r = r, ret.i = i;
    return ret;
}
Complex RealMult(Complex a, float b)
{
    Complex ret;
    ret.r = a.r * b;
    ret.i = a.i * b;
    return ret;
}
Complex Expi(float x)
{
    Complex ret;
    ret.r = cos(x);
    ret.i = sin(x);
    return ret;
}
float2 ExpiFloat(float x)
{
    float2 ret;
    ret.x = cos(x);
    ret.y = sin(x);
    return ret;
}

cbuffer TimeBuffer
{
    float _Time;
}

// Ocean Simulating Params
float _Amplitude;
float _ChoppyWavesLambda;

float2 _WindVelocity;
int _Octaves;

// GlobalParams
int _PatchVertexCount;
float _PatchSize;

// For Spectrum Calculation
RWStructuredBuffer<float3> _SpectrumH1;
RWStructuredBuffer<float3> _SpectrumH2;
float _SpectrumParamA;
//RWTexture2D<float4> _SpectrumTexture;


// For FFT Calculation
RWStructuredBuffer<float2> _FFTCoefficientW;
RWStructuredBuffer<int> _FFTButterflyIndices;
RWStructuredBuffer<float2> _FFTCalcBuffer;
RWStructuredBuffer<float2> _FFTGradientX;
RWStructuredBuffer<float2> _FFTGradientZ;
RWStructuredBuffer<float2> _Jacobian;


// Calc Result
RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> origPositions;
//RWStructuredBuffer<float3> normals;
//RWStructuredBuffer<float3> gradients;
//RWTexture2D<float4> _HeightTexture;
//RWTexture2D<float4> _DxTex, _DzTex;
//RWTexture2D<float4> _DisplacementTexture;
//RWTexture2D<float4> _NormalTexture;
//RWTexture2D<float4> _FoldingTexture;
RWTexture2D<float4> _JacobianTexture;



uint Hash(uint seed)
{
    return seed * 73856093u ^ (seed + 1919810u) * 19349663u;
}

float RandomFloat(uint seed)
{
    seed = (seed << 13) ^ seed;
    return (1.0 - ((seed * (seed * seed * 15731u + 789221u) + 1376312589u) & 0x7fffffff) / 2147483648.0);
    //1073741824
}

int getIndex(uint3 id)
{
    return id.y * _PatchVertexCount + id.x;;
}

//https:/en.wikipedia.org/wiki/Box–Muller_transform
float4 GaussianRandomVariableNum4(uint seed)
{
    float x1, x2, w;
    do
    {
        x1 = 2.0 * RandomFloat(seed) - 1.0;
        seed = Hash(seed);
        x2 = 2.0 * RandomFloat(seed) - 1.0;
        seed = Hash(seed);
        w = x1 * x1 + x2 * x2;
    } while (w >= 1.0);
    w = sqrt((-2.0 * log(w)) / w);
    
    
    float y1, y2, v;
    do
    {
        y1 = 2.0 * RandomFloat(seed) - 1.0;
        seed = Hash(seed);
        y2 = 2.0 * RandomFloat(seed) - 1.0;
        seed = Hash(seed);
        v = y1 * y1 + y2 * y2;
    } while (v >= 1.0);
    v = sqrt((-2.0 * log(v)) / v);
    
    return float4(x1 * w, x2 * w, y1 * v, y2 * v);
}



[numthreads(THREAD_X, 1, 1)]
void CalcFFTCoefficientW(uint3 id : SV_DispatchThreadID)
{
    float x = -2.0 * _Pi / _PatchVertexCount * (id.x - _PatchVertexCount / 2.0);
    Complex res = Expi(x);
    _FFTCoefficientW[id.x] = float2(res.r, res.i);
}

[numthreads(THREAD_X, THREAD_Y, 1)]
void CalcPhillipsSpectrum(uint3 id : SV_DispatchThreadID)
{
    //h(k,t)=h0(k)*exp(iw(k)t)+h^0(-k)*exp(-iw(k)t)
    //exp(iw(k)t) = cos(w(k)t) + isin(w(k)t)
    //exp(-iw(k)t)= cos(w(k)t) - isin(w(k)t)
    
    float k_x = 2.0 * _Pi / _PatchSize * (id.x - _PatchVertexCount / 2.0);
    float k_z = 2.0 * _Pi / _PatchSize * (id.y - _PatchVertexCount / 2.0);
    
    float2 k = float2(k_x, k_z);
    float k_length = max(length(k), 0.0001);
    float k_length2 = k_length * k_length;
    float k_length4 = k_length2 * k_length2;
    
    float V = max(length(_WindVelocity), 0.0001);
    float L = V * V / _G;
    float L2 = L * L;
    
    float kdotw = dot(k, _WindVelocity) / k_length / V;
    float kdotw2 = kdotw * kdotw;
    
    float Phil = _SpectrumParamA * exp(-1 / (k_length2 * L2)) / k_length4 * kdotw2;
    uint seed = id.y * 114u + id.x * 514u;
    float4 ksis = GaussianRandomVariableNum4(seed);
    Complex R1, R2;
    R1.r = ksis.x, R1.i = ksis.y;
    R2.r = ksis.x, R2.i =-ksis.y;
    //R2.r = ksis.z, R2.i = -ksis.w;
    
    Complex H1, H2;
    H1 = RealMult(R1, sqrt(Phil / 2.0));
    H2 = RealMult(R2, sqrt(Phil / 2.0));
    
    float omega_k = sqrt(_G * k_length);
    
   
    //float2 CosMult = H1 + H2;
    //float2 SinMult = (H1 - H2) * i
    int index = getIndex(id);
    
    _SpectrumH1[index] = float3(H1.r, H1.i, omega_k);
    _SpectrumH2[index] = float3(H2.r, H2.i, -omega_k);
    
    //Phil = _SpectrumParamA * exp(-1 / (k_length2 * L2)) / k_length4 * kdotw2;
    //_SpectrumH1[index] = float3(Phil, Phil, omega_k);
    //_SpectrumH2[index] = float3(Phil, Phil, -omega_k);
    
    //_SpectrumTexture[id.xy] = float4(H1.r + H2.r, H1.i - H2.i, omega_k, 0);
    //_SpectrumTexture[id.xy] = float4(Phil, Phil, omega_k, 0);

}

[numthreads(THREAD_X, THREAD_Y, 1)]
void CalcPhillipsSpectrumWithTime(uint3 id : SV_DispatchThreadID)
{
    int index = getIndex(id);
    
    Complex res1 = ComplexMult(Float2Complex(_SpectrumH1[index].x, _SpectrumH1[index].y), Expi(_SpectrumH1[index].z * _Time));
    Complex res2 = ComplexMult(Float2Complex(_SpectrumH2[index].x, _SpectrumH2[index].y), Expi(_SpectrumH2[index].z * _Time));
    float r = res1.r + res2.r;
    float i = res1.i + res2.i;
    //Complex E = Expi(_SpectrumTexture[id.xy].z * _Time);
    //float r = _SpectrumTexture[id.xy].x * E.r - _SpectrumTexture[id.xy].y * E.i;
    //float i = 0;
    
    _FFTCalcBuffer[index] = float2(r, i);
    
    float k_x = 2.0 * _Pi / _PatchSize * (id.x - _PatchVertexCount / 2.0);
    float k_z = 2.0 * _Pi / _PatchSize * (id.y - _PatchVertexCount / 2.0);
    float k_length = max(sqrt(k_x * k_x + k_z * k_z), 0.001);
    _FFTGradientX[index] = k_x / k_length * float2(i, -r);
    _FFTGradientZ[index] = k_z / k_length * float2(i, -r);
    _Jacobian[index] = (k_x * k_x + k_z * k_z) / k_length * float2(r, i);

}

[numthreads(THREAD_X, 1, 1)]
void CalcFFTonAxisZ(uint3 id : SV_DispatchThreadID)
{
    // s[i] = H[x][i] = _FFTCalcBuffer[x+i*N]
    int curX = id.x;
    int i, d;
    for (i = 0; i < _PatchVertexCount; i++)
    {
        //F[i] = F[i] * Expi((N / 2.0 - i) * _Pi);
        int ii = i * _PatchVertexCount + curX;
        float2 expi = ExpiFloat((_PatchVertexCount / 2.0 - i) * _Pi);
        _FFTCalcBuffer[ii] = ComplexMultFloat(_FFTCalcBuffer[ii], expi);
        _FFTGradientX[ii] = ComplexMultFloat(_FFTGradientX[ii], expi);
        _FFTGradientZ[ii] = ComplexMultFloat(_FFTGradientZ[ii], expi);
        _Jacobian[ii] = ComplexMultFloat(_Jacobian[ii], expi);
    }
    
    for (i = 0; i < _PatchVertexCount; i++)
    {
        int ii = i * _PatchVertexCount + curX, jj = _FFTButterflyIndices[i] * _PatchVertexCount + curX;
        if (ii >= jj)
            continue;
        float2 tmp;
        tmp = _FFTCalcBuffer[ii], _FFTCalcBuffer[ii] = _FFTCalcBuffer[jj], _FFTCalcBuffer[jj] = tmp;
        tmp = _FFTGradientX[ii], _FFTGradientX[ii] = _FFTGradientX[jj], _FFTGradientX[jj] = tmp;
        tmp = _FFTGradientZ[ii], _FFTGradientZ[ii] = _FFTGradientZ[jj], _FFTGradientZ[jj] = tmp;
        tmp = _Jacobian[ii], _Jacobian[ii] = _Jacobian[jj], _Jacobian[jj] = tmp;
    }
    
    
    for (i = 1, d = _PatchVertexCount >> 1; i < _PatchVertexCount; i <<= 1, d >>= 1)
    {
        for (int j = 0; j < _PatchVertexCount; j += i << 1)
        {
            for (int k = 0; k < i; ++k)
            {
                int ii = (j + k) * _PatchVertexCount + curX, jj = (j + k + i) * _PatchVertexCount + curX, kk = _PatchVertexCount - d * k;
                float2 x = _FFTCalcBuffer[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _FFTCalcBuffer[jj]);
                _FFTCalcBuffer[ii] = x + y;
                _FFTCalcBuffer[jj] = x - y;
               
                x = _FFTGradientX[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _FFTGradientX[jj]);
                _FFTGradientX[ii] = x + y;
                _FFTGradientX[jj] = x - y;
                
                x = _FFTGradientZ[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _FFTGradientZ[jj]);
                _FFTGradientZ[ii] = x + y;
                _FFTGradientZ[jj] = x - y;
                
                x = _Jacobian[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _Jacobian[jj]);
                _Jacobian[ii] = x + y;
                _Jacobian[jj] = x - y;
            }
        }
    }
    
    for (i = 0; i < _PatchVertexCount; i++)
    {
        //F[i] = F[i] * Expi(-_Pi * (i));
        int ii = i * _PatchVertexCount + curX;
        float2 expi = ExpiFloat(-_Pi * i);
        _FFTCalcBuffer[ii] = ComplexMultFloat(_FFTCalcBuffer[ii], expi);
        _FFTGradientX[ii] = ComplexMultFloat(_FFTGradientX[ii], expi);
        _FFTGradientZ[ii] = ComplexMultFloat(_FFTGradientZ[ii], expi);
        _Jacobian[ii] = ComplexMultFloat(_Jacobian[ii], expi);
    }
}

[numthreads(THREAD_X, 1, 1)]
void CalcFFTonAxisX(uint3 id : SV_DispatchThreadID)
{
    // s[i] = H[i][y] = _FFTCalcBuffer[i+y*N]
    int curY = id.x;
    int i, d;
    for (i = 0; i < _PatchVertexCount; i++)
    {
        //F[i] = F[i] * Expi((N / 2.0 - i) * _Pi);
        int ii = i + _PatchVertexCount * curY;
        float2 expi = ExpiFloat((_PatchVertexCount / 2.0 - i) * _Pi);
        _FFTCalcBuffer[ii] = ComplexMultFloat(_FFTCalcBuffer[ii], expi);
        _FFTGradientX[ii] = ComplexMultFloat(_FFTGradientX[ii], expi);
        _FFTGradientZ[ii] = ComplexMultFloat(_FFTGradientZ[ii], expi);
        _Jacobian[ii] = ComplexMultFloat(_Jacobian[ii], expi);
    }
    
    for (i = 0; i < _PatchVertexCount; i++)
    {
        int ii = i + _PatchVertexCount * curY, jj = _FFTButterflyIndices[i] + _PatchVertexCount * curY;
        if (ii >= jj)
            continue;
        float2 tmp;
        tmp = _FFTCalcBuffer[ii], _FFTCalcBuffer[ii] = _FFTCalcBuffer[jj], _FFTCalcBuffer[jj] = tmp;
        tmp = _FFTGradientX[ii], _FFTGradientX[ii] = _FFTGradientX[jj], _FFTGradientX[jj] = tmp;
        tmp = _FFTGradientZ[ii], _FFTGradientZ[ii] = _FFTGradientZ[jj], _FFTGradientZ[jj] = tmp;
        tmp = _Jacobian[ii], _Jacobian[ii] = _Jacobian[jj], _Jacobian[jj] = tmp;
    }
    
    for (i = 1, d = _PatchVertexCount >> 1; i < _PatchVertexCount; i <<= 1, d >>= 1)
    {
        for (int j = 0; j < _PatchVertexCount; j += i << 1)
        {
            for (int k = 0; k < i; ++k)
            {
                int ii = (j + k) + _PatchVertexCount * curY, jj = (j + k + i) + _PatchVertexCount * curY, kk = _PatchVertexCount - d * k;
                float2 x = _FFTCalcBuffer[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _FFTCalcBuffer[jj]);
                _FFTCalcBuffer[ii] = x + y;
                _FFTCalcBuffer[jj] = x - y;
               
                x = _FFTGradientX[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _FFTGradientX[jj]);
                _FFTGradientX[ii] = x + y;
                _FFTGradientX[jj] = x - y;
                
                x = _FFTGradientZ[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _FFTGradientZ[jj]);
                _FFTGradientZ[ii] = x + y;
                _FFTGradientZ[jj] = x - y;
                
                x = _Jacobian[ii], y = ComplexMultFloat(_FFTCoefficientW[kk], _Jacobian[jj]);
                _Jacobian[ii] = x + y;
                _Jacobian[jj] = x - y;
            }
        }
    }
    
    for (i = 0; i < _PatchVertexCount; i++)
    {
        //F[i] = F[i] * Expi(-_Pi * (i));
        int ii = i + _PatchVertexCount * curY;
        float2 expi = ExpiFloat(-_Pi * i);
        _FFTCalcBuffer[ii] = ComplexMultFloat(_FFTCalcBuffer[ii], expi);
        _FFTGradientX[ii] = ComplexMultFloat(_FFTGradientX[ii], expi);
        _FFTGradientZ[ii] = ComplexMultFloat(_FFTGradientZ[ii], expi);
        _Jacobian[ii] = ComplexMultFloat(_Jacobian[ii], expi);
    }
}


[numthreads(THREAD_X, THREAD_Y, 1)]
void updateHeight(uint3 id : SV_DispatchThreadID)
{
    int index = getIndex(id);
    float2 pos = positions[index].xz;
    
    float Scale_Factor = _PatchSize / _PatchVertexCount * _Amplitude;
    float h = _FFTCalcBuffer[index].x * Scale_Factor;
    float dx = _FFTGradientX[index].x * Scale_Factor;
    float dz = _FFTGradientZ[index].x * Scale_Factor;
    float J = _Jacobian[index].x * Scale_Factor * _ChoppyWavesLambda + 1;
    
    positions[index].x = origPositions[index].x + _ChoppyWavesLambda * dx;
    positions[index].z = origPositions[index].z + _ChoppyWavesLambda * dz;
    positions[index].y = _FFTCalcBuffer[index].x * Scale_Factor;
    
    _JacobianTexture[id.xy] = float4(J, J, J, 1);
    //gradients[index] = float3(dx, 0, dz);
    //normals[index] = normalize(float3(-dx, 1, -dz));
    //_HeightTexture[id.xy] = float4(h, h, h, 1);
    //_DxTex[id.xy] = float4(dx, dx, dx, 1);
    //_DzTex[id.xy] = float4(dz, dz, dz, 1);
//    _DisplacementTexture[id.xy] = float4(dx, h, dz, 1);
    //_NormalTexture;
    //_FoldingTexture;
}

[numthreads(THREAD_X, THREAD_Y, 1)]
void CalcHeightByDFT(uint3 id : SV_DispatchThreadID)
{
    int index = getIndex(id);
    float x = positions[index].x;
    float z = positions[index].z;
    Complex sum;
    sum.r = 0, sum.i = 0;
    for (int i = 0; i < _PatchVertexCount; i++)
    {
        for (int j = 0; j < _PatchVertexCount; j++)
        {
            float k_x = 2.0 * _Pi / _PatchSize * (i - _PatchVertexCount / 2.0);
            float k_z = 2.0 * _Pi / _PatchSize * (j - _PatchVertexCount / 2.0);
            //Complex res = ComplexMult(Float2Complex(_FFTCalcBuffer[j * _PatchVertexCount + i].x, _FFTCalcBuffer[j * _PatchVertexCount + i].y), Expi(k_x * x + k_z * z));
            Complex res = ComplexMult(Float2Complex(_FFTCalcBuffer[j * _PatchVertexCount + i].x, _FFTCalcBuffer[j * _PatchVertexCount + i].y), Expi(2 * _Pi / _PatchVertexCount *
            ((i - _PatchVertexCount / 2.0) * (id.x - _PatchVertexCount / 2.0) + (j - _PatchVertexCount / 2.0) * (id.y - _PatchVertexCount / 2.0))));
            sum.r += res.r;
            sum.i += res.i;
        }
    }
    
    positions[index].y = sum.r / 30;

}   